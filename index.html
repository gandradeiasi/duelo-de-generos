<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Duelo de Gêneros Spotify</title>
  <!-- Bootstrap CSS para responsividade e estilo -->
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
  <style>
    body { padding: 20px; }
    .genre-btn { margin: 10px; font-size: 1.5rem; }
    .artist-item { cursor: pointer; padding: 10px; border-bottom: 1px solid #ddd; }
    .artist-item:hover { background-color: #f8f9fa; }
    .progress { margin-bottom: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="text-center">Duelo de Gêneros Spotify</h1>
    
    <!-- Seção de login -->
    <div id="login-section" class="text-center my-4">
      <button id="login-btn" class="btn btn-success btn-lg">Logar com o Spotify</button>
    </div>
    
    <!-- Seção de progresso -->
    <div id="progress-section" style="display:none;">
      <h4>Carregando dados...</h4>
      <div class="progress">
        <div id="progress-bar" class="progress-bar" role="progressbar" style="width: 0%;" aria-valuemin="0" aria-valuemax="100">0%</div>
      </div>
    </div>
    
    <!-- Seção de duelo -->
    <div id="duel-section" style="display:none;" class="text-center">
      <h2>Escolha seu Gênero</h2>
      <div id="duel-buttons" class="d-flex justify-content-center flex-wrap">
        <!-- Aqui serão inseridos os botões dos gêneros -->
      </div>
      <button id="done-btn" class="btn btn-primary mt-3">Pronto</button>
    </div>
    
    <!-- Seção de resultado -->
    <div id="result-section" style="display:none;">
      <h2>Gênero vencedor: <span id="winning-genre"></span></h2>
      <div id="artists-list" class="mt-4">
        <!-- Lista dos artistas do gênero vencedor -->
      </div>
    </div>
  </div>
  
  <!-- Scripts JavaScript -->
  <script>
    // Variáveis globais para armazenar os dados
    let accessToken = null;
    // Estrutura para cada gênero: { score: 0, artists: { [artistId]: count } }
    let genreData = {};
    // Lista de gêneros que ainda não participaram do duelo
    let unusedGenres = [];
    // Lista de gêneros que já foram exibidos no duelo (para empates)
    let duelledGenres = [];
    // Dados completos dos artistas: { [artistId]: { name, genres, savedCount } }
    let allArtistData = {};

    // Atualiza a barra de progresso (0 a 100%)
    function updateProgress(percent) {
      const progressBar = document.getElementById('progress-bar');
      progressBar.style.width = percent + '%';
      progressBar.innerText = percent + '%';
    }

    // Obtém o token de acesso a partir da URL (hash)
    function getAccessTokenFromHash() {
      const hash = window.location.hash.substring(1);
      const params = new URLSearchParams(hash);
      return params.get('access_token');
    }

    // Função para redirecionar para o login do Spotify
    function login() {
      const clientId = 'cdbe0b644b984a6e98839e352d87bb3d';
      const redirectUri = window.location.origin + window.location.pathname;
      const scopes = 'user-library-read';
      const authUrl = 'https://accounts.spotify.com/authorize' +
        '?response_type=token' +
        '&client_id=' + encodeURIComponent(clientId) +
        '&scope=' + encodeURIComponent(scopes) +
        '&redirect_uri=' + encodeURIComponent(redirectUri);
      window.location = authUrl;
    }

    document.getElementById('login-btn').addEventListener('click', login);

    // Ao carregar a página, verifica se há token de acesso
    window.onload = async function() {
      accessToken = getAccessTokenFromHash();
      if (accessToken) {
        document.getElementById('login-section').style.display = 'none';
        document.getElementById('progress-section').style.display = 'block';
        await fetchSavedTracks();
      }
    };

    // Busca todas as músicas salvas, utilizando paginação de 50 em 50 itens
    async function fetchSavedTracks() {
      let allTracks = [];
      let limit = 50;
      let offset = 0;
      let total = 1; // valor inicial dummy para entrar no loop
      while (offset < total) {
        let response = await fetch(`https://api.spotify.com/v1/me/tracks?limit=${limit}&offset=${offset}`, {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });
        let data = await response.json();
        total = data.total;
        allTracks = allTracks.concat(data.items);
        offset += limit;
        // Atualiza a barra de progresso (primeiros 50% para músicas)
        let percent = Math.min(50, Math.floor((offset / total) * 50));
        updateProgress(percent);
      }
      await processTracks(allTracks);
    }

    // Processa as músicas salvas para contar quantas vezes cada artista aparece
    async function processTracks(tracks) {
      let artistCounts = {}; // { artistId: count }
      tracks.forEach(item => {
        let track = item.track;
        track.artists.forEach(artist => {
          artistCounts[artist.id] = (artistCounts[artist.id] || 0) + 1;
        });
      });
      // Após contar, busca os detalhes de cada artista
      let artistIds = Object.keys(artistCounts);
      await fetchArtistDetails(artistIds, artistCounts);
    }

    // Busca os detalhes dos artistas em lotes de 50 (conforme paginação)
    async function fetchArtistDetails(artistIds, artistCounts) {
      let batchSize = 50;
      for (let i = 0; i < artistIds.length; i += batchSize) {
        let batch = artistIds.slice(i, i + batchSize);
        let response = await fetch('https://api.spotify.com/v1/artists?ids=' + batch.join(','), {
          headers: { 'Authorization': 'Bearer ' + accessToken }
        });
        let data = await response.json();
        data.artists.forEach(artist => {
          allArtistData[artist.id] = {
            name: artist.name,
            genres: artist.genres,
            savedCount: artistCounts[artist.id] || 0
          };
        });
        // Atualiza a barra de progresso (próximos 50% para artistas)
        let percent = 50 + Math.floor(((i + batch.length) / artistIds.length) * 50);
        updateProgress(percent);
      }
      buildGenreData();
    }

    // Constrói a estrutura de gêneros a partir dos dados dos artistas
    function buildGenreData() {
      for (let artistId in allArtistData) {
        let artist = allArtistData[artistId];
        artist.genres.forEach(genre => {
          if (!genreData[genre]) {
            genreData[genre] = { score: 0, artists: {} };
            unusedGenres.push(genre);
          }
          // Soma a quantidade de músicas salvas daquele artista para o gênero
          genreData[genre].artists[artistId] = (genreData[genre].artists[artistId] || 0) + artist.savedCount;
        });
      }
      // Embaralha a lista de gêneros que ainda não foram duelados
      unusedGenres = shuffleArray(unusedGenres);
      // Oculta a barra de progresso e exibe a seção de duelo
      document.getElementById('progress-section').style.display = 'none';
      document.getElementById('duel-section').style.display = 'block';
      nextDuelRound();
    }

    // Função utilitária para embaralhar um array
    function shuffleArray(array) {
      let currentIndex = array.length, temporaryValue, randomIndex;
      while (currentIndex !== 0) {
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex -= 1;
        temporaryValue = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = temporaryValue;
      }
      return array;
    }

    // Lógica do duelo: determina qual par de gêneros será exibido a seguir
    function nextDuelRound() {
      let pair = getNextDuelPair();
      if (!pair) {
        // Se não houver mais pares disponíveis, o usuário poderá finalizar
        return;
      }
      displayDuelPair(pair[0], pair[1]);
    }

    // Retorna o próximo par de gêneros de acordo com as regras:
    // Se existir 2 ou mais gêneros (dos que já participaram) com a mesma pontuação, eles serão o par.
    // Só sorteia 2 novos se não houver tal empate; e os sorteados são removidos dos que ainda não participaram.
    function getNextDuelPair() {
      let scoreGroups = {};
      duelledGenres.forEach(genre => {
        let score = genreData[genre].score;
        if (!scoreGroups[score]) scoreGroups[score] = [];
        if (!scoreGroups[score].includes(genre)) scoreGroups[score].push(genre);
      });
      for (let score in scoreGroups) {
        if (scoreGroups[score].length >= 2) {
          let group = shuffleArray(scoreGroups[score]);
          return [group[0], group[1]];
        }
      }
      if (unusedGenres.length >= 2) {
        let genre1 = unusedGenres.pop();
        let genre2 = unusedGenres.pop();
        duelledGenres.push(genre1, genre2);
        return [genre1, genre2];
      }
      return null;
    }

    // Exibe os dois gêneros na tela em ordem aleatória
    function displayDuelPair(genre1, genre2) {
      let container = document.getElementById('duel-buttons');
      container.innerHTML = '';
      let pair = shuffleArray([genre1, genre2]);
      pair.forEach(genre => {
        let btn = document.createElement('button');
        btn.className = 'btn btn-outline-secondary genre-btn';
        btn.innerText = genre + ' (' + genreData[genre].score + ' ponto' + (genreData[genre].score !== 1 ? 's' : '') + ')';
        btn.onclick = function() {
          // Ao selecionar, o gênero ganha 1 ponto e inicia novo duelo
          genreData[genre].score++;
          nextDuelRound();
        };
        container.appendChild(btn);
      });
    }

    // Ao clicar em "Pronto", determina o gênero com maior pontuação
    document.getElementById('done-btn').addEventListener('click', function() {
      let winner = null;
      for (let genre in genreData) {
        if (!winner || genreData[genre].score > genreData[winner].score) {
          winner = genre;
        }
      }
      document.getElementById('duel-section').style.display = 'none';
      displayWinner(winner);
    });

    // Exibe o gênero vencedor e lista os artistas relacionados, ordenados por quantidade de músicas salvas
    function displayWinner(winnerGenre) {
      document.getElementById('result-section').style.display = 'block';
      document.getElementById('winning-genre').innerText = winnerGenre + ' (' + genreData[winnerGenre].score + ' pontos)';
      let artists = [];
      for (let artistId in genreData[winnerGenre].artists) {
        artists.push({
          id: artistId,
          name: allArtistData[artistId].name,
          savedCount: genreData[winnerGenre].artists[artistId]
        });
      }
      artists.sort((a, b) => b.savedCount - a.savedCount);
      let listDiv = document.getElementById('artists-list');
      listDiv.innerHTML = '<h3>Artistas com o gênero ' + winnerGenre + ':</h3>';
      artists.forEach(artist => {
        let div = document.createElement('div');
        div.className = 'artist-item';
        div.innerText = artist.name + ' (' + artist.savedCount + ' músicas)';
        div.onclick = function() {
          window.open('https://open.spotify.com/artist/' + artist.id, '_blank');
        };
        listDiv.appendChild(div);
      });
    }
  </script>
</body>
</html>
