<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Genre Sorter</title>
    <style>
        /* ----- CSS Starts Here ----- */
        :root {
            --spotify-green: #1DB954;
            --spotify-black: #191414;
            --spotify-white: #FFFFFF;
            --light-gray: #f4f4f4;
            --medium-gray: #ccc;
            --dark-gray: #535353;
        }

        body {
            font-family: 'Helvetica Neue', Arial, sans-serif;
            background-color: var(--spotify-black);
            color: var(--spotify-white);
            margin: 0;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align top for scroll */
            min-height: 100vh;
            box-sizing: border-box;
        }

        .container {
            background-color: rgba(40, 40, 40, 0.8);
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            text-align: center;
            max-width: 900px;
            width: 90%;
            box-sizing: border-box;
            margin-top: 20px; /* Add some margin at the top */
            margin-bottom: 20px; /* Add some margin at the bottom */
        }

        h1, h2, h3 {
            color: var(--spotify-green);
        }

        h1 {
            margin-bottom: 30px;
        }

        h2 {
            margin-top: 20px;
            margin-bottom: 20px;
        }

        h3 {
            margin-top: 30px;
            margin-bottom: 15px;
            color: var(--spotify-white);
            border-bottom: 1px solid var(--dark-gray);
            padding-bottom: 5px;
            text-align: left; /* Align heading left */
        }

        button {
            background-color: var(--spotify-green);
            color: var(--spotify-white);
            border: none;
            padding: 12px 25px;
            border-radius: 50px; /* Pill shape */
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease;
            margin: 10px 5px;
        }

        button:hover {
            background-color: #1ed760;
            transform: scale(1.03);
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
             background-color: var(--dark-gray);
             cursor: not-allowed;
             transform: none;
             opacity: 0.7; /* Indicate disabled state */
        }


        #login-button {
            font-size: 1.2rem;
            padding: 15px 35px;
        }

        .action-button {
            background-color: var(--dark-gray);
        }
        .action-button:hover:not(:disabled) { /* Only apply hover if not disabled */
            background-color: #6a6a6a;
        }


        .hidden {
            display: none !important; /* Use important to override potential conflicts */
        }

        /* Loading Section */
        #loading-section {
            margin-top: 30px;
        }

        .progress-container {
            margin-bottom: 20px;
            text-align: left;
        }

        .progress-container label {
            display: block;
            margin-bottom: 5px;
            color: var(--medium-gray);
        }

        progress {
            width: 100%;
            height: 15px;
            border-radius: 10px;
            overflow: hidden; /* Ensures the fill stays within bounds */
            border: 1px solid var(--dark-gray);
            appearance: none; /* Remove default styling */
             background-color: var(--dark-gray); /* Fallback background */
        }

        /* Styling progress bar for Chrome/Safari/Edge */
        progress::-webkit-progress-bar {
            background-color: var(--dark-gray);
            border-radius: 10px;
        }

        progress::-webkit-progress-value {
            background-color: var(--spotify-green);
            border-radius: 10px; /* Full radius looks better */
            transition: width 0.3s ease; /* Smooth animation */
        }

        /* Styling progress bar for Firefox */
        progress::-moz-progress-bar {
            background-color: var(--spotify-green);
            border-radius: 10px;
            transition: width 0.3s ease; /* Smooth animation */
        }


        #tracks-progress-text,
        #artists-progress-text {
            display: inline-block; /* Changed to inline-block */
            margin-left: 10px;
            font-size: 0.9em;
            color: var(--medium-gray);
            min-width: 35px; /* Ensure space for 100% */
            text-align: right;
            vertical-align: middle; /* Align with progress bar */
        }

         /* Wrapper for progress bar and text */
         .progress-wrapper {
            display: flex;
            align-items: center;
            gap: 10px; /* Space between bar and text */
        }
        .progress-wrapper progress {
            flex-grow: 1; /* Allow progress bar to take up space */
        }


        #loading-status {
            margin-top: 15px;
            font-style: italic;
            color: var(--medium-gray);
            min-height: 1.2em; /* Reserve space */
        }


        /* Sorting Section */
        .genre-options {
            display: flex;
            justify-content: center;
            align-items: stretch; /* Make buttons same height */
            gap: 15px; /* Space between buttons and separator */
            margin-bottom: 20px;
            flex-wrap: wrap; /* Allow wrapping on small screens */
        }

        .genre-button {
            flex: 1; /* Allow buttons to grow */
            min-width: 150px; /* Minimum width before wrapping */
            padding: 20px 15px; /* More padding for bigger click area */
            font-size: 1.1rem;
            white-space: normal; /* Allow text wrapping */
            word-wrap: break-word; /* Break long words if needed */
            min-height: 60px; /* Ensure consistent height */
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .or-separator {
            display: flex;
            align-items: center;
            font-size: 1.2rem;
            color: var(--medium-gray);
            font-weight: bold;
        }

        /* Results Section */
        .winner-display {
            margin-top: 15px;
            margin-bottom: 30px;
            display: flex; /* Use flexbox for winners */
            justify-content: center; /* Center winners */
            flex-wrap: wrap; /* Wrap if many winners */
            gap: 10px; /* Space between winner buttons */
        }

        .winner-genre-button {
            background-color: var(--spotify-green);
            color: var(--spotify-white);
            border: 2px solid transparent; /* Add transparent border for layout consistency */
            padding: 15px 30px;
            border-radius: 50px;
            font-size: 1.3rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s ease, transform 0.1s ease, border-color 0.2s ease;
            margin: 5px; /* Keep margin for spacing */
            /* display: inline-block; Remove this if using flexbox */
        }
        .winner-genre-button:hover {
            background-color: #1ed760;
            transform: scale(1.03);
        }
        .winner-genre-button.selected { /* Style for selected winner */
             border-color: var(--spotify-white);
             background-color: #1aa34a; /* Slightly darker green */
        }


        #artist-list-container {
            margin-top: 20px;
            text-align: left;
            max-height: 400px; /* Limit height and make scrollable */
            overflow-y: auto; /* Enable vertical scroll */
            border: 1px solid var(--dark-gray);
            border-radius: 5px;
            padding: 15px;
            background-color: rgba(50, 50, 50, 0.5); /* Slightly different background */
        }


        #artist-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #artist-list li {
            padding: 12px 10px;
            border-bottom: 1px solid var(--dark-gray);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.2s ease;
        }

        #artist-list li:last-child {
            border-bottom: none;
        }

        #artist-list li:hover {
            background-color: rgba(83, 83, 83, 0.7); /* Highlight on hover */
        }


        #artist-list a {
            color: var(--spotify-white);
            text-decoration: none;
            font-weight: bold;
            flex-grow: 1; /* Take available space */
            margin-right: 15px; /* Space before track count */
        }

        #artist-list a:hover {
            color: var(--spotify-green);
            text-decoration: underline;
        }

        #artist-list span {
            color: var(--medium-gray);
            font-size: 0.9em;
            white-space: nowrap; /* Prevent count from wrapping */
            flex-shrink: 0; /* Prevent shrinking */
        }

        /* Error Message */
        .error-message {
            color: #ff4d4d; /* Red color for errors */
            background-color: rgba(255, 77, 77, 0.1);
            border: 1px solid #ff4d4d;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }

        .error-message p {
            margin: 5px 0;
        }

        .error-message button {
            background-color: #ff4d4d;
            margin-top: 10px;
        }
        .error-message button:hover {
            background-color: #ff6666;
        }


        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                 align-items: flex-start; /* Keep alignment top */
            }
            .container {
                padding: 20px;
                width: 95%;
            }

            h1 {
                font-size: 1.8rem;
            }

            .genre-options {
                flex-direction: column; /* Stack options vertically */
                gap: 10px;
            }

            .genre-button {
                width: 100%; /* Full width buttons */
                min-width: unset;
                padding: 15px;
            }

            .or-separator {
                margin: 10px 0; /* Space when stacked */
                align-self: center; /* Center separator when stacked */
            }

            #artist-list-container {
                max-height: 300px; /* Adjust height for smaller screens */
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
                align-items: flex-start;
            }
            .container {
                padding: 15px;
                margin-top: 10px;
                margin-bottom: 10px;
            }
            h1 {
                font-size: 1.5rem;
                margin-bottom: 20px;
            }
            h2 {
                font-size: 1.2rem;
            }
            button, #login-button {
                font-size: 0.9rem;
                padding: 10px 20px;
            }
            .genre-button {
                font-size: 1rem;
                padding: 12px 10px;
                min-height: 50px;
            }
            .winner-genre-button {
                font-size: 1.1rem;
                padding: 12px 25px;
            }

            #artist-list li {
                padding: 10px 8px;
                flex-direction: column; /* Stack artist name and count */
                align-items: flex-start; /* Align items left */
                gap: 5px; /* Space between name and count */
            }
            #artist-list a {
                margin-right: 0; /* Remove right margin */
                 font-size: 0.95rem;
            }
            #artist-list span {
                font-size: 0.8em;
                align-self: flex-end; /* Move count to the right */
            }

            .progress-wrapper {
                 flex-direction: column;
                 align-items: stretch; /* Make items full width */
                 gap: 5px;
            }
            #tracks-progress-text,
            #artists-progress-text {
                 text-align: center; /* Center progress text */
                 margin-left: 0;
                 min-width: auto;
                 width: 100%;
            }
        }
        /* ----- CSS Ends Here ----- */
    </style>
</head>
<body>
    <div class="container">
        <h1>Descubra seu Gênero Favorito no Spotify</h1>

        <div id="login-section">
            <button id="login-button">Logar com Spotify</button>
        </div>

        <div id="loading-section" class="hidden">
            <h2>Carregando seus dados...</h2>
            <div class="progress-container">
                <label for="tracks-progress">Carregando Músicas Salvas:</label>
                <div class="progress-wrapper">
                    <progress id="tracks-progress" value="0" max="100"></progress>
                    <span id="tracks-progress-text">0%</span>
                </div>
            </div>
            <div class="progress-container">
                <label for="artists-progress">Carregando Detalhes dos Artistas:</label>
                 <div class="progress-wrapper">
                    <progress id="artists-progress" value="0" max="100"></progress>
                    <span id="artists-progress-text">0%</span>
                 </div>
            </div>
            <p id="loading-status"></p>
        </div>

        <div id="sorting-section" class="hidden">
            <h2>Qual gênero você prefere?</h2>
            <div id="genre-options" class="genre-options">
                <button id="genre-a" class="genre-button" disabled></button> <span class="or-separator">OU</span>
                <button id="genre-b" class="genre-button" disabled></button> </div>
            <button id="finish-button" class="action-button">Pronto</button>
        </div>

        <div id="results-section" class="hidden">
            <h2>Seu Gênero Favorito é:</h2>
            <div id="winner-display" class="winner-display">
                </div>
            <div id="artist-list-container" class="hidden">
                 <h3>Artistas Relacionados (Suas Músicas Salvas):</h3>
                 <ul id="artist-list">
                     </ul>
            </div>
        </div>

        <div id="error-section" class="hidden error-message">
            <p>Ocorreu um erro:</p>
            <p id="error-message-text"></p>
            <button onclick="window.location.href = REDIRECT_URI || window.location.pathname;">Tentar Novamente</button> </div>
    </div>

    <script>
        // ----- JavaScript Starts Here -----
        // ----- Configuração -----
        const CLIENT_ID = 'cdbe0b644b984a6e98839e352d87bb3d'; // SEU CLIENT ID FORNECIDO
        const REDIRECT_URI = window.location.origin + window.location.pathname; // Ou a URI exata cadastrada
        const SPOTIFY_AUTHORIZE_ENDPOINT = 'https://accounts.spotify.com/authorize';
        const SPOTIFY_API_BASE_URL = 'https://api.spotify.com/v1';
        const SCOPES = 'user-library-read'; // Permissão necessária para ler músicas salvas
        const PAGINATION_LIMIT = 50;

        // ----- Elementos da UI -----
        const loginButton = document.getElementById('login-button');
        const loginSection = document.getElementById('login-section');
        const loadingSection = document.getElementById('loading-section');
        const tracksProgress = document.getElementById('tracks-progress');
        const tracksProgressText = document.getElementById('tracks-progress-text');
        const artistsProgress = document.getElementById('artists-progress');
        const artistsProgressText = document.getElementById('artists-progress-text');
        const loadingStatus = document.getElementById('loading-status');
        const sortingSection = document.getElementById('sorting-section');
        const genreButtonA = document.getElementById('genre-a');
        const genreButtonB = document.getElementById('genre-b');
        const finishButton = document.getElementById('finish-button');
        const resultsSection = document.getElementById('results-section');
        const winnerDisplay = document.getElementById('winner-display');
        const artistListContainer = document.getElementById('artist-list-container');
        const artistListUl = document.getElementById('artist-list');
        const errorSection = document.getElementById('error-section');
        const errorMessageText = document.getElementById('error-message-text');

        // ----- Estado da Aplicação -----
        let accessToken = null;
        let userSavedTracks = []; // Array de objetos de faixa simplificados
        let artistDetails = {}; // { artistId: { name, genres, url, savedTrackCount } }
        let allGenres = new Set(); // Usar Set para garantir unicidade
        let genreScores = {}; // { genreName: score }
        let currentPair = []; // [genreA, genreB]
        let activeGenresList = []; // Lista de todos os gêneros para sorteio
        let randomlySelectedGenres = new Set(); // << NOVO: Rastreia gêneros já sorteados ALEATORIAMENTE
        let isFetching = false; // Flag para evitar múltiplas chamadas
        let isSortingActive = false; // Flag para controlar cliques durante o sorteio

        // ----- Funções -----

        // Função para mostrar/ocultar seções
        function showSection(sectionElement) {
            loginSection.classList.add('hidden');
            loadingSection.classList.add('hidden');
            sortingSection.classList.add('hidden');
            resultsSection.classList.add('hidden');
            errorSection.classList.add('hidden');
            if (sectionElement) {
                sectionElement.classList.remove('hidden');
            }
        }

        // Função para exibir erros
        function showError(message, showLoginButton = false) {
            console.error("Erro:", message);
            errorMessageText.textContent = message;
            // O botão "Tentar Novamente" agora redireciona para a página inicial sem o hash
            const retryButton = errorSection.querySelector('button');
            if (retryButton) {
                 // Simplesmente recarrega a página base, forçando re-autenticação se necessário
                 retryButton.onclick = () => { window.location.href = REDIRECT_URI || window.location.pathname; };
            }

            showSection(errorSection);
             // Opcionalmente mostrar botão de login se o erro for de autenticação
            if (showLoginButton) {
                 loginSection.classList.remove('hidden');
            }
             // Para o sorteio se um erro ocorrer durante ele
             isSortingActive = false;
             genreButtonA.disabled = true;
             genreButtonB.disabled = true;

        }

        // Função para atualizar barra de progresso
        function updateProgress(progressBar, progressText, current, total) {
            // Garante que current não exceda total para a barra de progresso
            const cappedCurrent = Math.min(current, total || 0); // Adiciona || 0 para evitar NaN se total for undefined inicialmente
            const percentage = (total > 0) ? Math.round((cappedCurrent / total) * 100) : 0;
            progressBar.value = percentage;
            // progressBar.max = 100; // Definido no HTML
            progressText.textContent = `${percentage}%`;

             // Atualiza o texto de status também, se aplicável (pode ser mais detalhado)
            // loadingStatus.textContent = `Progresso: ${current} de ${total}`;
        }

        // Função para lidar com a autenticação do Spotify
        function handleAuthentication() {
            const params = new URLSearchParams(window.location.hash.substring(1)); // Pega da #
            const token = params.get('access_token');
            const error = params.get('error');
             const state = params.get('state');
             const storedState = localStorage.getItem('spotify_auth_state');

            // Verifica o state para proteção CSRF
            if (state && (!storedState || state !== storedState)) {
                showError("Erro de autenticação: Parâmetro 'state' inválido. Possível ataque CSRF.", true);
                localStorage.removeItem('spotify_auth_state'); // Limpa o state inválido
                window.location.hash = ''; // Limpa o hash
                return;
            }
             localStorage.removeItem('spotify_auth_state'); // Limpa o state após verificação bem-sucedida


             if (error) {
                showError(`Erro de autenticação do Spotify: ${error}. Por favor, tente logar novamente.`, true);
                window.location.hash = ''; // Limpa o hash
                return;
             }


            if (token) {
                accessToken = token;
                // Limpa o hash da URL por segurança e para evitar reprocessamento
                history.pushState("", document.title, window.location.pathname + window.location.search);
                console.log("Token obtido com sucesso!");
                startDataFetching();
            } else if (!isFetching) { // Só mostra login se não houver token E não estiver buscando dados
                showSection(loginSection); // Mostra botão de login se não houver token
            }
        }

        // Função para redirecionar para o Spotify para login
        function redirectToSpotifyLogin() {
             if (!CLIENT_ID || CLIENT_ID === 'SEU_CLIENT_ID_AQUI') {
                 showError("Erro de Configuração: O Client ID do Spotify não foi definido.");
                 return;
             }
            // Gera um estado aleatório para segurança (CSRF protection)
            const state = generateRandomString(16);
            localStorage.setItem('spotify_auth_state', state); // Armazena para verificar no retorno

            const authUrl = `${SPOTIFY_AUTHORIZE_ENDPOINT}?client_id=${CLIENT_ID}&redirect_uri=${encodeURIComponent(REDIRECT_URI)}&scope=${encodeURIComponent(SCOPES)}&response_type=token&state=${state}&show_dialog=true`;
            window.location.href = authUrl;
        }

        // Função auxiliar para gerar string aleatória
        function generateRandomString(length) {
            let text = '';
            const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
            for (let i = 0; i < length; i++) {
                text += possible.charAt(Math.floor(Math.random() * possible.length));
            }
            return text;
        }


        // Função genérica para chamadas API (simplificada, focando na paginação e erros comuns)
        async function fetchSpotifyAPI(url, options = {}) {
            if (!accessToken) {
                 // Não joga erro aqui diretamente, apenas retorna null ou objeto de erro
                 // para ser tratado pelo chamador, evitando parar toda a execução
                 console.error("Token de acesso não disponível.");
                 showError("Sua sessão expirou ou é inválida. Por favor, faça login novamente.", true);
                 return { error: true, message: "Token de acesso não disponível." };
            }

            const defaultOptions = {
                headers: { 'Authorization': `Bearer ${accessToken}` }
            };
            const mergedOptions = { ...defaultOptions, ...options };

            try {
                const response = await fetch(url, mergedOptions);

                if (!response.ok) {
                    let errorDetails = `${response.status}: ${response.statusText}`;
                     try { // Tenta ler o corpo da resposta de erro
                         const errorBody = await response.json();
                         errorDetails += ` - ${errorBody.error?.message || JSON.stringify(errorBody)}`;
                     } catch (e) { /* Ignora se não conseguir ler o corpo */ }

                    // Tratamento específico de erros
                    if (response.status === 401) {
                         accessToken = null; // Invalida o token
                         console.error("Erro 401 - Token inválido/expirado:", errorDetails);
                         showError("Token de acesso inválido ou expirado. Por favor, faça login novamente.", true);
                         return { error: true, status: 401, message: "Token inválido/expirado." };
                    }
                    if (response.status === 429) {
                        const retryAfter = parseInt(response.headers.get('Retry-After') || '5', 10);
                        console.warn(`Limite de requisições (429). Tentando novamente em ${retryAfter} segundos... URL: ${url}`);
                         loadingStatus.textContent += ` (Aguardando ${retryAfter}s...)`; // Atualiza status
                        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000 + 100)); // Adiciona 100ms extra
                        return fetchSpotifyAPI(url, mergedOptions); // Tenta a mesma requisição novamente
                    }
                     // Outros erros
                     console.error(`Erro na API do Spotify (${errorDetails}). URL: ${url}`);
                     showError(`Falha na comunicação com a API (${response.status}). Tente recarregar.`);
                     return { error: true, status: response.status, message: `Erro na API: ${errorDetails}` };
                }

                // Retorna null se for uma resposta 204 No Content, comum em PUT/DELETE
                if (response.status === 204) {
                    return null;
                }

                return await response.json(); // Retorna os dados JSON

            } catch (networkError) {
                 // Erro de rede (offline, DNS, etc.)
                 console.error("Erro de Rede:", networkError);
                 showError(`Falha na comunicação com a API: ${networkError.message}. Verifique sua conexão.`);
                 return { error: true, message: `Erro de Rede: ${networkError.message}` };
            }
        }


        // Função para buscar TODAS as músicas salvas com paginação
        async function fetchAllSavedTracks() {
            let tracks = [];
            let nextUrl = `${SPOTIFY_API_BASE_URL}/me/tracks?limit=${PAGINATION_LIMIT}`;
            let totalItems = null; // Começa como null
            let fetchedCount = 0;

             loadingStatus.textContent = `Músicas: Iniciando busca...`;
             updateProgress(tracksProgress, tracksProgressText, 0, 1); // Inicia barra (max 1 = 0%)

            try {
                 while (nextUrl) {
                     const data = await fetchSpotifyAPI(nextUrl);

                     // Verifica se houve erro na chamada da API
                     if (data?.error) {
                         throw new Error(data.message || "Erro ao buscar página de músicas.");
                     }
                     if (!data) { // Caso a API retorne algo inesperado
                          throw new Error("Resposta inválida da API ao buscar músicas.");
                     }


                    if (totalItems === null && typeof data.total === 'number') {
                        totalItems = data.total; // Pega o total na primeira resposta
                        console.log(`Total de músicas salvas reportado pela API: ${totalItems}`);
                         updateProgress(tracksProgress, tracksProgressText, fetchedCount, totalItems); // Atualiza max da barra
                     }

                    const currentItems = data.items || [];
                     tracks = tracks.concat(currentItems);
                     fetchedCount += currentItems.length;

                    // Atualiza progresso (usa fetchedCount como total se totalItems ainda for null)
                    const currentTotal = totalItems ?? fetchedCount; // Usa total real se disponível
                    updateProgress(tracksProgress, tracksProgressText, fetchedCount, currentTotal);
                     loadingStatus.textContent = `Músicas: Buscando... ${fetchedCount}${totalItems !== null ? ` de ${totalItems}` : ''}`;


                     nextUrl = data.next; // URL para a próxima página ou null

                    // Pausa pequena entre páginas
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
            } catch (error) {
                // Erro já foi mostrado por showError dentro de fetchSpotifyAPI ou aqui
                 console.error("Falha no loop de busca de músicas:", error);
                 if (!errorSection.classList.contains('hidden')) { /* Já mostrou erro? */ }
                 else { showError(`Erro ao buscar músicas salvas: ${error.message}`); }
                return null; // Indica falha
            }

             loadingStatus.textContent = `Músicas: Busca concluída. ${tracks.length} encontradas.`;
            return tracks; // Retorna a lista completa de itens de faixa salvos
        }


       // Função para buscar detalhes dos artistas (em lotes de 50)
        async function fetchArtistDetails(trackItems) {
            const artistIds = new Set();
            // Mapeia os IDs dos artistas principais de cada faixa salva
            trackItems.forEach(item => {
                if (item?.track?.artists) { // Adiciona checagens de nulidade
                     item.track.artists.forEach(artist => {
                         if(artist?.id) artistIds.add(artist.id)
                     });
                }
            });

            const uniqueArtistIds = Array.from(artistIds);
            const totalArtistsToFetch = uniqueArtistIds.length;
             if (totalArtistsToFetch === 0) {
                 console.warn("Nenhum ID de artista encontrado nas faixas.");
                 updateProgress(artistsProgress, artistsProgressText, 0, 0);
                 loadingStatus.textContent = `Artistas: Nenhum artista para buscar.`;
                 return {}; // Retorna objeto vazio
             }

            let fetchedArtistCount = 0;
            let allArtistDetails = {}; // Armazena os detalhes aqui

            console.log(`Buscando detalhes para ${totalArtistsToFetch} artistas únicos...`);
            loadingStatus.textContent = `Artistas: Iniciando busca...`;
            updateProgress(artistsProgress, artistsProgressText, 0, totalArtistsToFetch);

            try {
                // Processar em lotes de 50 (limite da API)
                 for (let i = 0; i < totalArtistsToFetch; i += PAGINATION_LIMIT) {
                    const batchIds = uniqueArtistIds.slice(i, i + PAGINATION_LIMIT);
                    if (batchIds.length === 0) continue; // Pula lotes vazios

                    const url = `${SPOTIFY_API_BASE_URL}/artists?ids=${batchIds.join(',')}`;
                     const data = await fetchSpotifyAPI(url);

                     // Verifica se houve erro na chamada da API
                     if (data?.error) {
                         throw new Error(data.message || `Erro ao buscar lote ${i / PAGINATION_LIMIT + 1} de artistas.`);
                     }
                     if (!data?.artists) { // Checa se a resposta contém a lista de artistas
                         console.warn(`Resposta inválida da API ao buscar artistas (lote ${i / PAGINATION_LIMIT + 1}):`, data);
                         // Continua para o próximo lote, mas loga o aviso
                         fetchedArtistCount += batchIds.length; // Assume que o lote falhou, mas avança a contagem
                         continue;
                     }

                    const artistsData = data.artists;

                     artistsData.forEach(artist => {
                         if (artist?.id && artist.name) { // Checa se o artista retornado tem ID e nome
                            // Não precisamos mais contar aqui, faremos isso depois
                             allArtistDetails[artist.id] = {
                                name: artist.name,
                                genres: artist.genres || [],
                                url: artist.external_urls?.spotify, // Checa nulidade
                                id: artist.id // Guarda o ID para referência futura
                                // savedTrackCount será calculado depois
                            };
                            // Adiciona gêneros ao Set global
                             (artist.genres || []).forEach(genre => {
                                 if (genre && typeof genre === 'string' && genre.trim() !== '') { // Garante que o gênero é válido
                                      allGenres.add(genre.trim().toLowerCase()); // Padroniza para minúsculas
                                 }
                             });
                         } else {
                             console.warn(`API retornou artista inválido ou nulo no lote: ${batchIds.join(',')}`, artist);
                         }
                    });

                     // Atualiza o contador baseado no número de IDs enviados no lote
                     fetchedArtistCount += batchIds.length;
                    // Garante que o progresso não ultrapasse o total
                    const currentProgress = Math.min(fetchedCount, totalArtistsToFetch); // Corrigido para usar fetchedCount correto
                    updateProgress(artistsProgress, artistsProgressText, currentProgress, totalArtistsToFetch);
                     loadingStatus.textContent = `Artistas: Buscando... ${currentProgress} de ${totalArtistsToFetch}`;

                    // Pausa pequena
                    await new Promise(resolve => setTimeout(resolve, 75)); // Aumentei um pouco a pausa
                }
            } catch (error) {
                // Erro já foi mostrado por showError dentro de fetchSpotifyAPI ou aqui
                 console.error("Falha no loop de busca de artistas:", error);
                 if (!errorSection.classList.contains('hidden')) { /* Já mostrou erro? */ }
                 else { showError(`Erro ao buscar detalhes dos artistas: ${error.message}`); }
                return null; // Indica falha
            }


            // Agora, calcula a contagem de músicas salvas para cada artista
            Object.values(allArtistDetails).forEach(artist => {
                 let count = 0;
                 trackItems.forEach(item => {
                     if (item?.track?.artists?.some(a => a.id === artist.id)) { // Checagem de nulidade
                         count++;
                     }
                 });
                 artist.savedTrackCount = count;
             });


            loadingStatus.textContent = `Artistas: Busca concluída. Detalhes de ${Object.keys(allArtistDetails).length} artistas carregados.`;
            console.log(`Total de ${allGenres.size} gêneros únicos encontrados:`, Array.from(allGenres).sort());
            return allArtistDetails; // Retorna o objeto com detalhes dos artistas
        }

        // Função para iniciar a busca de dados após o login
        async function startDataFetching() {
             if (isFetching) {
                 console.log("Busca de dados já em andamento.");
                 return;
             }
             isFetching = true; // Marca como buscando
             showSection(loadingSection);
             // Reseta estado anterior se houver
             userSavedTracks = [];
             artistDetails = {};
             allGenres = new Set();
             genreScores = {};
             randomlySelectedGenres = new Set();
             activeGenresList = [];
             currentPair = [];


            // 1. Buscar todas as músicas salvas
             const savedTrackItems = await fetchAllSavedTracks();
             if (!savedTrackItems) {
                 isFetching = false; // Reseta flag em caso de erro
                 // Erro já foi mostrado
                 return;
             }
             // Simplifica os dados das faixas se necessário (opcional)
             userSavedTracks = savedTrackItems.filter(item => item?.track?.id && item.track.name && item.track.artists?.length > 0) // Filtra faixas inválidas
                                             .map(item => ({
                                                 id: item.track.id,
                                                 name: item.track.name,
                                                 artists: item.track.artists.map(a => ({ id: a.id, name: a.name, url: a.external_urls.spotify }))
                                             }));
             if (userSavedTracks.length !== savedTrackItems.length) {
                  console.warn(`Filtradas ${savedTrackItems.length - userSavedTracks.length} faixas inválidas ou sem artistas.`);
             }
             if (userSavedTracks.length === 0 && savedTrackItems.length > 0) {
                 showError("Nenhuma faixa válida com artistas encontrada em suas músicas salvas.");
                 isFetching = false;
                 return;
             }


             // 2. Buscar detalhes dos artistas
             const fetchedArtistDetails = await fetchArtistDetails(savedTrackItems); // Passa os itens completos
             if (fetchedArtistDetails === null) { // Checa explicitamente por null indicando erro
                 isFetching = false; // Reseta flag em caso de erro
                 // Erro já foi mostrado
                 return;
             }
             artistDetails = fetchedArtistDetails;


            // 3. Prepara para o sorteio
            if (allGenres.size < 2) {
                const foundGenres = allGenres.size > 0 ? Array.from(allGenres).join(', ') : 'Nenhum';
                showError(`Não foram encontrados gêneros suficientes (mínimo 2) nos artistas das suas músicas salvas para iniciar o sorteio. Encontrados: ${foundGenres}.`);
                isFetching = false;
                return;
            }

            activeGenresList = Array.from(allGenres).sort(); // Ordena para consistência
            activeGenresList.forEach(genre => { genreScores[genre] = 0; }); // Inicializa placar
            randomlySelectedGenres = new Set(); // Garante que está limpo

            console.log("Dados carregados, iniciando sorteio...");
             isFetching = false; // Terminou a busca
             startSorting();
        }

        // ----- Lógica do Sorteio -----

        function startSorting() {
             if (activeGenresList.length < 2) {
                  showError("Não há gêneros suficientes para iniciar o sorteio.");
                  return;
             }
             isSortingActive = true; // Ativa o sorteio
             displayNextPair(); // Mostra o primeiro par
             showSection(sortingSection);
        }


        // --- getRandomGenres MODIFICADA ---
        // Seleciona 2 gêneros para o duelo com as novas regras
        function getRandomGenres() {
            if (activeGenresList.length < 2) {
                console.warn("Tentando sortear com menos de 2 gêneros ativos.");
                return [];
            }

            // 1. Prioritize Ties (Highest score first)
            const scoresMap = {};
            for (const [genre, score] of Object.entries(genreScores)) {
                if (!scoresMap[score]) {
                    scoresMap[score] = [];
                }
                scoresMap[score].push(genre);
            }

            // Find the highest score level with at least 2 genres tied
            const sortedScores = Object.keys(scoresMap).map(Number).sort((a, b) => b - a); // Scores descending

            for (const score of sortedScores) {
                const tiedGenres = scoresMap[score];
                if (tiedGenres && tiedGenres.length >= 2) {
                    console.log(`Prioritizing tie at score ${score}: ${tiedGenres.join(', ')}`);
                    // Randomly select two different genres from this tied group
                    let indexA, indexB;
                    // Adiciona uma proteção simples contra loop infinito se tiedGenres tiver apenas 1 elemento (não deveria acontecer aqui)
                    if (tiedGenres.length < 2) continue;
                    do {
                        indexA = Math.floor(Math.random() * tiedGenres.length);
                        indexB = Math.floor(Math.random() * tiedGenres.length);
                    } while (indexA === indexB);
                    // Return the tied pair - DO NOT add to randomlySelectedGenres
                    return [tiedGenres[indexA], tiedGenres[indexB]];
                }
            }

            // 2. No Ties Found - Select Randomly (Avoiding Repeats)
            console.log("No ties found, selecting randomly avoiding repeats.");

            // Determine genres available for random selection
            const availableForRandom = activeGenresList.filter(genre => !randomlySelectedGenres.has(genre));
            console.log(`Available for random selection (${availableForRandom.length}): ${availableForRandom.join(', ') || 'None'}`);
            // console.log(`Already selected randomly (${randomlySelectedGenres.size}): ${Array.from(randomlySelectedGenres).join(', ') || 'None'}`);


            let selectedPair = [];

            if (availableForRandom.length >= 2) {
                // Select two different genres from the available pool
                console.log("Selecting from available pool...");
                let indexA, indexB;
                do {
                    indexA = Math.floor(Math.random() * availableForRandom.length);
                    indexB = Math.floor(Math.random() * availableForRandom.length);
                } while (indexA === indexB);
                selectedPair = [availableForRandom[indexA], availableForRandom[indexB]];
                console.log(`Selected randomly from available: ${selectedPair.join(' vs ')}`);
            } else {
                // Not enough available, reset the 'randomly selected' list and pick from all
                console.warn("Resetting randomly selected list as < 2 available. Picking from all active genres.");
                randomlySelectedGenres.clear(); // Reset the set

                if (activeGenresList.length < 2) { // Double check after reset possibility
                     console.error("Cannot select pair, less than 2 active genres overall.");
                     return [];
                }

                let indexA, indexB;
                 // Select two different genres from the *full* active list
                console.log("Selecting from ALL active genres after reset...");
                do {
                    indexA = Math.floor(Math.random() * activeGenresList.length);
                    indexB = Math.floor(Math.random() * activeGenresList.length);
                } while (indexA === indexB);
                 selectedPair = [activeGenresList[indexA], activeGenresList[indexB]];
                console.log(`Selected randomly from ALL after reset: ${selectedPair.join(' vs ')}`);
            }

            // Add the *randomly* selected pair to the tracking set
            if (selectedPair.length === 2) {
                randomlySelectedGenres.add(selectedPair[0]);
                randomlySelectedGenres.add(selectedPair[1]);
                 // console.log(`Updated randomlySelectedGenres: ${Array.from(randomlySelectedGenres).join(', ')}`);
            } else {
                 console.error("Failed to select a valid pair.");
                 return []; // Retorna vazio se falhar
            }

            return selectedPair;
        }
        // --- Fim da getRandomGenres MODIFICADA ---


        // Exibe o próximo par de gêneros
        function displayNextPair() {
            // Garante que o estado está pronto
             if (!activeGenresList || activeGenresList.length < 2) {
                 showError("Estado inválido para continuar o sorteio.");
                 isSortingActive = false;
                 return;
             }

            currentPair = getRandomGenres();
             if (!currentPair || currentPair.length < 2) {
                console.warn("Não foi possível obter um par de gêneros válido. Finalizando.");
                finishSorting(); // Finaliza se não houver mais pares válidos
                return;
            }

            // Habilita os botões antes de definir o texto
             genreButtonA.disabled = false;
             genreButtonB.disabled = false;


            // Ordem aleatória na tela
            const displayOrder = Math.random() < 0.5 ? [currentPair[0], currentPair[1]] : [currentPair[1], currentPair[0]];

            genreButtonA.textContent = displayOrder[0];
            genreButtonA.dataset.genre = displayOrder[0]; // Armazena o gênero no botão
            genreButtonB.textContent = displayOrder[1];
            genreButtonB.dataset.genre = displayOrder[1];
        }

        // Função chamada ao clicar em um gênero
        function selectGenre(event) {
             if (!isSortingActive || event.target.disabled) return; // Ignora cliques se o sorteio não está ativo ou botão desabilitado

            const selectedGenre = event.target.dataset.genre;

             // Desabilita botões brevemente para evitar cliques duplos
             genreButtonA.disabled = true;
             genreButtonB.disabled = true;

            if (selectedGenre && genreScores.hasOwnProperty(selectedGenre)) {
                genreScores[selectedGenre]++;
                console.log(`Ponto para: ${selectedGenre}. Placar:`, Object.entries(genreScores).filter(([,s])=> s > 0).sort(([,a],[,b]) => b-a)); // Log placar ordenado > 0
                // Pequena pausa antes de mostrar o próximo par (feedback visual)
                 setTimeout(displayNextPair, 150); // 150ms de pausa
            } else {
                 console.error("Gênero selecionado inválido ou não encontrado:", selectedGenre, event.target);
                 showError("Ocorreu um erro ao selecionar o gênero. Tente recarregar a página.");
                 // Reabilita botões em caso de erro inesperado? Não, deixa desabilitado.
             }
        }

        // Função para finalizar o sorteio e mostrar resultados
        function finishSorting() {
             isSortingActive = false; // Desativa o sorteio
            console.log("Finalizando sorteio...");
             genreButtonA.disabled = true; // Garante que botões estão desabilitados
             genreButtonB.disabled = true;
             showSection(resultsSection);
             artistListContainer.classList.add('hidden'); // Esconde lista de artistas inicialmente

             if (Object.keys(genreScores).length === 0) {
                 winnerDisplay.innerHTML = '<p>Nenhum gênero foi pontuado.</p>';
                 return;
             }

             // Filtra apenas gêneros com pontuação > 0 para determinar o vencedor
             const validScores = Object.entries(genreScores).filter(([, score]) => score > 0);

             if (validScores.length === 0) {
                  winnerDisplay.innerHTML = '<p>Nenhum gênero recebeu pontos.</p>';
                  return;
             }

            const maxScore = Math.max(...validScores.map(([, score]) => score));
            const winners = validScores.filter(([_, score]) => score === maxScore)
                                     .map(([genre]) => genre)
                                     .sort(); // Ordena vencedores alfabeticamente

            console.log("Gênero(s) vencedor(es):", winners, "com pontuação:", maxScore);

            winnerDisplay.innerHTML = ''; // Limpa vencedores anteriores
            if (winners.length > 0) {
                winners.forEach(winner => {
                    const winnerButton = document.createElement('button');
                    winnerButton.textContent = winner;
                    winnerButton.classList.add('winner-genre-button');
                    winnerButton.dataset.genre = winner;
                    winnerButton.addEventListener('click', displayArtistsForGenre);
                    winnerDisplay.appendChild(winnerButton);
                });
                 // Se houver apenas um vencedor, mostra os artistas imediatamente
                if (winners.length === 1) {
                    // Simula o clique no botão do vencedor para mostrar os artistas
                     displayArtistsForGenre({ target: winnerDisplay.firstChild });
                 }
             } else {
                 // Isso não deve acontecer devido à checagem de validScores.length > 0, mas por segurança:
                 winnerDisplay.innerHTML = '<p>Não foi possível determinar um gênero vencedor.</p>';
             }
        }


        // Função para exibir artistas do gênero selecionado
        function displayArtistsForGenre(event) {
            const selectedGenre = event.target.dataset.genre;
            if (!selectedGenre) return; // Sai se não houver gênero no botão

            console.log(`Mostrando artistas para o gênero: ${selectedGenre}`);

            // Realça o botão do gênero clicado (adiciona/remove classe 'selected')
            document.querySelectorAll('.winner-genre-button').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.genre === selectedGenre);
            });

            artistListUl.innerHTML = ''; // Limpa lista anterior

            // Filtra artistas que contêm o gênero selecionado E TEM MÚSICAS SALVAS
            // Certifique-se de que artistDetails existe e tem dados
             if (!artistDetails || Object.keys(artistDetails).length === 0) {
                  console.warn("Detalhes dos artistas não disponíveis para filtragem.");
                  artistListUl.innerHTML = '<li>Erro ao carregar detalhes dos artistas.</li>';
                  artistListContainer.classList.remove('hidden');
                  return;
             }

            const filteredArtists = Object.values(artistDetails)
                .filter(artist => artist?.genres?.includes(selectedGenre) && artist.savedTrackCount > 0) // Adiciona checagem de nulidade
                .sort((a, b) => b.savedTrackCount - a.savedTrackCount); // Ordena por contagem de músicas salvas (desc)

            console.log(`Encontrados ${filteredArtists.length} artistas para ${selectedGenre} com músicas salvas.`);

            if (filteredArtists.length === 0) {
                const li = document.createElement('li');
                li.textContent = `Nenhum artista com o gênero "${selectedGenre}" encontrado entre suas músicas salvas.`;
                 li.style.justifyContent = 'center'; // Centraliza a mensagem
                artistListUl.appendChild(li);
            } else {
                filteredArtists.forEach(artist => {
                    if (!artist?.name || !artist.url) return; // Pula artistas inválidos

                    const li = document.createElement('li');
                    const link = document.createElement('a');
                    link.href = artist.url;
                    link.textContent = artist.name;
                    link.target = '_blank'; // Abre em nova aba
                    link.rel = 'noopener noreferrer'; // Segurança

                    const countSpan = document.createElement('span');
                     // Pluralização simples
                     const trackText = artist.savedTrackCount === 1 ? 'música salva' : 'músicas salvas';
                     countSpan.textContent = `${artist.savedTrackCount} ${trackText}`;

                    li.appendChild(link);
                    li.appendChild(countSpan);
                    artistListUl.appendChild(li);
                });
            }

            artistListContainer.classList.remove('hidden'); // Mostra a lista de artistas
            // Scroll para a lista de artistas se ela estiver fora da visão
            artistListContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }


        // ----- Inicialização -----
        document.addEventListener('DOMContentLoaded', () => {
             // Adiciona listeners aos botões principais
             loginButton.addEventListener('click', redirectToSpotifyLogin);
             genreButtonA.addEventListener('click', selectGenre);
             genreButtonB.addEventListener('click', selectGenre);
             finishButton.addEventListener('click', finishSorting);

             // Verifica autenticação ao carregar a página
             handleAuthentication();
        });

        // ----- JavaScript Ends Here -----
    </script>
</body>
</html>
